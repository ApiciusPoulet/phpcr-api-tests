<?php

namespace PHPCR\Tests\Observation;

use \PHPCR\Observation\EventInterface;


require_once(__DIR__ . '/../../inc/BaseCase.php');

/**
 * Tests for the ObservationManager
 *
 * Covering jcr-2.8.3 spec $12
 */
class ObservationManagerTest extends \PHPCR\Test\BaseCase
{
    public function testGetUnfilteredEventJournal()
    {
        sleep(1); // To avoid having the same date as the journal entries generated by the fixtures loading

        $curTime = strtotime('now');

        $producerSession = self::$loader->getSession();
        $consumerSession = self::$loader->getSession();
        $consumerOm = $consumerSession->getWorkspace()->getObservationManager();

        // Produce some events in the producer session

        $this->produceEvents($producerSession);

        // Read the events in the consumer session

        $this->expectEvents($consumerOm->getEventJournal(), $curTime);
    }

    /**
     * Produce the following entries at the end of the event journal:
     *
     *      PROPERTY_ADDED      /child/jcr:primaryType
     *      NODE_ADDED          /child
     *      PERSIST
     *      PROPERTY_ADDED      /child/prop
     *      PERSIST
     *      PROPERTY_CHANGED    /child/prop
     *      PERSIST
     *      PROPERTY_REMOVED    /child/prop
     *      PERSIST
     *      NODE_REMOVED        /child
     *      PERSIST
     *
     * WARNING:
     * If you change the events (or the order of events) produced here, you
     * will have to adapt self::expectEvents so that it checks for the correct
     * events.
     *
     * @param $session
     * @return void
     */
    protected function produceEvents($session)
    {
        $root = $session->getRootNode();
        $node = $root->addNode('child');             // Will cause a PROPERTY_ADDED + a NODE_ADDED event
        $session->save();                            // Will cause a PERSIST event

        $prop = $node->setProperty('prop', 'value'); // Will case a PROPERTY_ADDED event
        $session->save();                            // Will cause a PERSIST event

        $prop->setValue('something else');           // Will cause a PROPERTY_CHANGED event
        $session->save();                            // Will cause a PERSIST event

        $prop->remove();                             // Will cause a PROPERTY_REMOVED event
        $session->save();                            // Will cause a PERSIST event

        $node->remove();                             // Will cause a NODE_REMOVED event
        $session->save();                            // Will cause a PERSIST event

        // TODO: cause a NODE_MOVED event
    }

    /**
     * Check if the expected events are in the event journal.
     *
     * WARNING:
     * This function will expect the events produced by self::produceEvents
     * If you add or remove events from self::produceEvents, you will have
     * to adapt this function so that it expects the correct events in the
     * correct order.
     *
     * @param $journal
     * @param int $startDate The timestamp to use with EventJournal::skipTo to reach the wanted events
     * @return void
     */
    protected function expectEvents($journal, $startDate)
    {
        $journal->skipTo($startDate);

        $this->assertTrue($journal->valid());

        $this->assertEvent(EventInterface::PROPERTY_ADDED, '/child/jcr%3aprimaryType', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::NODE_ADDED, '/child/', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::PERSIST, '', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::PROPERTY_ADDED, '/child/prop', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::PERSIST, '', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::PROPERTY_CHANGED, '/child/prop', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::PERSIST, '', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::PROPERTY_REMOVED, '/child/prop', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::PERSIST, '', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::NODE_REMOVED, '/child/', $journal->current());

        $journal->next();
        $this->assertEvent(EventInterface::PERSIST, '', $journal->current());

        $journal->next();
        $this->assertFalse($journal->valid());
    }

    /**
     * Assert an event of the event journal has the expected type and path.
     * @param int $expectedType
     * @param string $expectedPath
     * @param \PHPCR\Observation\EventInterface $event
     * @return void
     */
    protected function assertEvent($expectedType, $expectedPath, EventInterface $event)
    {
        $this->assertInstanceOf('\PHPCR\Observation\EventInterface', $event);
        $this->assertEquals($expectedType, $event->getType());
        $this->assertEquals($expectedPath, $event->getPath());
    }
}
